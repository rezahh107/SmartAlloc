# سند نهایی تجمیع‌شده — به‌روزرسانی ۱۹ شهریور ۱۴۰۴ (2025-09-07) — نسخهٔ نهایی ادغام‌شده

Note: Patch Guard: branch-type limits — see `PATCH_GUARD_STANDARDS_WordPress_2025-09-07.md` (feature ≤20/600; hotfix ≤5/150; bugfix ≤8/200; refactor ≤15/500; perf ≤12/350; security ≤8/200; docs ≤30/800; tests ≤25/700; i18n ≤50/1000; migration ≤15/400; compatibility ≤10/300).

## 🎯 PROJECT LEADERSHIP PULSE (vs. Baseline: 10 شهریور 1404)

**Phase:** foundation (Target: پشتِ خطِ مبنا)
**Progress:** ≈ ۶۸٪ (Baseline: ۸۰٪)

### ⚠️ Top 3 Deviations & Actions

1.  **RuleEngine Composite — نگهبان عمق (maxDepth=4) و مدیریت اپراتور نامعتبر کامل نیست**
    *   **Impact:** High
    *   **Action:** تکمیل `evaluateCompositeRule()` + تست‌های منفی (Invalid operator/Too-deep)
    *   **Owner:** Core

2.  **NotificationService — نبود throttling پویا و نبود شاخص‌های DLQ در متریک‌ها**
    *   **Probability:** 60% · **Impact:** Medium
    *   **Mitigation:** تنظیمات پویا (فیلتر/Option)، شمارنده‌های `notify.rate_limited` و `dlq.size`، مسیر بازاجرایی امن
    *   **Owner:** Core + Comms

3.  **GF Double-processing Risk — دو مسیر موازی برای `gform_after_submission`**
    *   **Impact:** High
    *   **Action:** انتخاب مسیر واحد (رجیستری per-form یا generic) و Deprecate مسیر دیگر
    *   **Owner:** Core

## 📊 Baseline Comparison (YAML)

```yaml
baseline_comparison:
  ref_date: "2025-09-07"
  phase: "foundation"
  progress_current: "≈66–70%"
  progress_baseline: "80%"
  critical_gaps:
    - "RuleEngine: نگهبان عمق/اپراتور نامعتبر + تست‌های منفی"
    - "NotificationService: throttling پویا + DLQ metrics"
    - "GF double-processing: یک مسیر واحد برای after_submission"
  emerging_risks:
    - "UTC invariants: استفاده از current_time('mysql') بدون GMT=true"
    - "SchemaChecker صوری — باید وجود/نوع فیلدهای کلیدی راستی‌آزمایی شود"
  advancement_opps:
    - "Plugin Health در Site Health + Wrapperها (PluginGuard/GFBridge/ASBridge)"
    - "Action Scheduler به‌عنوان صف استاندارد + DLQ/Backoff"
```

## 🔧 Plugin Integration Policy (خلاصه و الزام‌آور)

*   **Forms:** Gravity Forms (قطعی؛ منبع حقیقت جمع‌آوری داده). فرم v2 با فیلدهای کلیدی (ID: 143, 92, 93, 20, 21, 23, 30, 29, 94, 75, 76, 60, 61, 39, 99, 150, 151).
*   **Queue/Async:** Action Scheduler (Must-Have) — گروه `smartalloc`, backoff: 1m→5m→15m→30m، حداکثر ۴ تلاش، DLQ فعال.
*   **Mentor Populate (#39):** Hybrid — اگر GPPA حاضر بود Live/AJAX؛ اگر نبود Fallback داخلی (هوک‌های GF). فیلدهای وابسته: 92, 93, 94, 75.
*   **Email:** SMTP فقط Prod (WP Mail SMTP با SPF/DKIM/DMARC)؛ Dev: Mail Log + ماسک PII.
*   **Rule-of-One:** WP Webhooks/Automator فعلاً نصب نشود (Webhook داخلی کفایت می‌کند).
*   **UTC:** ذخیره‌سازی زمان‌ها در UTC (`current_time('mysql', true)`/`gmdate()`/`current_time('timestamp', true)`)؛ نمایش محلی صرفاً در UI.
*   **SchemaChecker:** واقعی‌سازی بررسی وجود/نوع فیلدهای کلیدی GF (IDs حیاتی: 39, 20, 92, 93, 94, 75, ...) و گزارش «Compatibility» در UI.

## ⚡️ Weekly Priorities (Baseline-Aligned)

1.  RuleEngine Composite + تست‌های منفی (Invalid/Too-deep)
2.  Notification throttling پویا + DLQ metrics + Replay امن
3.  Action Scheduler Switch (پیش‌فرض صف) + گروه‌ها و Backoff
4.  SchemaChecker واقعی + حذف دوگانگی مسیر GF

## 🎯 KPI و آستانه‌ها

*   **Queue:** Failed < ۱٪, p95 انتظار < ۱۰s, DLQ ≤ ۵
*   **Allocation:** p95 < ۸۰ms, Capacity deviation ≤ ۵٪, Mentor conflict = ۰
*   **Export:** Peak mem < ۱۲۸MB, Build ≤ ۲s (@N≈1000), CSV-Injection = ۰
*   **Comms:** Delivery ≥ ۹۸٪, Duplicate = ۰
*   **Forms:** Submission error < ۰.۵٪, GF schema compatibility = ۱۰۰٪

## 📊 Baseline Achievement Matrix (Critical Items Only)

| Component  | Baseline Target          | Current Status | Action                                        | Owner   |
| ---------- | ------------------------ | -------------- | --------------------------------------------- | ------- |
| RuleEngine | Composite AND/OR + Depth | ناقص           | تکمیل evaluateCompositeRule + تست عمق/اپراتور | Core    |
| Security   | ≥ 20                     | 21 (بهبودپذیر) | سفت‌کردن ورودی‌ها در DLQ/Webhook/UTC            | Sec     |
| Export     | Streaming + CSV-Safe     | نیمه‌کامل       | حد حافظه + ضد CSV-Injection تأیید مجدد        | Core+QA |

## ✅ Decisions (ثبت‌شده برای مبنا)

*   تثبیت GF به‌عنوان زیرساخت فرم (بدون تغییر مسیر فعلی).
*   مهاجرت صف به Action Scheduler؛ WP-Cron فقط fallback.
*   Mentor#39 به‌صورت Hybrid (GPPA اختیاری) با Wrapper و Fallback داخلی.
*   SMTP فقط Prod؛ Dev فقط Mail Log با ماسک PII.
*   اعمال Rule-of-One روی اتوماسیون؛ فعلاً وب‌هوک داخلی کافی است.
*   سفت‌کردن UTC در ذخیره‌سازی و نمایش محلی در UI.
*   تکمیل Site Health: Plugin Health Dashboard + KPIها.

---

## ---8<--- CLAUDE ARCHITECT PROMPT ---8<---

**FEATURE BRIEF (AUTO-GENERATED FROM STRATEGIC ANALYSIS)**

**🎯 Goal**
به‌روزرسانی مبنا با سیاست ادغام افزونه‌ها، مهاجرت صف به Action Scheduler، واقعی‌سازی SchemaChecker و یک‌مسیره‌کردن GF submission؛ بستن شکاف‌های RuleEngine Composite و Throttling/DLQ.

**📦 Scope (Baseline-Informed)**
*   Wrapperها: PluginGuard, GFBridge, ASBridge
*   Action Scheduler Groups/Backoff/DLQ
*   SchemaChecker واقعی + حذف مسیر موازی GF
*   KPIها و Site Health: Plugin Health
*   بدون تغییر در منطق هسته Allocation/Export

**📋 Baseline Requirements**
*   تکمیل آیتم‌های Foundation بحرانی
*   Security ≥ 22، Performance ≥ 19، Weighted ≥ 95%
*   UTC invariants رعایت شود؛ بدون رگرسیون

**⚠️ Constraints**
*   Patch Guard: branch-type caps (feature ≤20/600; hotfix ≤5/150; bugfix ≤8/200; refactor ≤15/500; perf ≤12/350; security ≤8/200; docs ≤30/800; tests ≤25/700; i18n ≤50/1000; migration ≤15/400; compatibility ≤10/300). See `PATCH_GUARD_STANDARDS_WordPress_2025-09-07.md`.
*   WordPress standards: prepared SQL, capability checks, UTC
*   Baseline Compliance: بدون رگرسیون

**ROLE:** Principal Software Architect for SmartAlloc (WordPress) with Baseline Compliance.
**NON-NEGOTIABLES:** prepared SQL; capability checks; nonce; typed exceptions; UTC; WP standards; baseline alignment.

**INPUT — Feature Brief:** [SEE ABOVE] + Baseline Requirements

**OUTPUT (STRICT):**

**PHASES (YAML)**
```yaml
baseline_update:
  phase: foundation
  goals:
    - migrate_queue_to_as
    - unify_gf_submission_path
    - implement_schema_checker_real
    - add_plugin_health_site_health
  deliverables:
    - src/Integration/ASBridge.php
    - src/Integration/PluginGuard.php
    - src/Infra/GF/SchemaChecker.php (real)
    - src/Admin/Status/PluginHealth.php
  5d_targets:
    security: 22
    logic: 18
    performance: 19
    readability: 19
    goal: 14
```

**TECH SPEC (MD)**

*   **ASBridge:** `queue($hook, $args, $delay, $group='smartalloc')` با backoff نمایی و DLQ hook. پیاده‌سازی `RetryService` با jitter و `DlqService` برای مدیریت صف مرده.
*   **SchemaChecker:** اعتبار فیلدهای کلیدی GF (IDs حیاتی)، خروجی سازگاری برای UI FormsScreen. بررسی وجود، نوع و الزامی‌بودن فیلدها.
*   **PluginHealth:** تست نسخه/فعال‌بودن افزونه‌ها (GF, AS, SMTP)، Rule-of-One، وضعیت DLQ/AS، UTC invariant. خروجی اقدام‌محور با لینک به صفحات مربوطه.
*   **GF Single Path:** تنها `gform_after_submission_{formId}` فعال. مسیر generic غیرفعال/Deprecated. پیاده‌سازی `IdempotencyGuard` برای جلوگیری از پردازش تکراری بر اساس `entry_id`.

**TEST PLAN (MD)**

*   ماتریس CI «با/بی‌افزونه» برای fallback (GPPA/AS).
*   تست double-processing GF: تنها یک مسیر فعال باشد؛ تست idempotency.
*   تست AS: failed actions ثبت و قابل replay؛ backoff pattern صحیح.
*   تست‌های منفی RuleEngine: عمق > 4، اپراتور نامعتبر.
*   تست‌های UTC: هیچ استفاده‌ای از `current_time('mysql')` بدون `GMT=true` وجود نداشته باشد.

**CODEX PROMPT (MD) — minimal diffs + exact paths**

*   افزودن فایل‌های فوق (≤25 LoC هر کدام)؛ تغییرات موضعی Bootstrap (≤10 LoC).
*   تغییرات Diff-Only با مسیر دقیق فایل‌ها.

**5D TARGETS (YAML)**
```yaml
targets:
  security: {min: 22, goal: 23}
  logic: {min: 18, goal: 18}
  performance: {min: 19, goal: 19}
  readability: {min: 19, goal: 19}
  goal: {min: 14, goal: 15}
```

**BASELINE IMPACT ASSESSMENT**

*   **Risk ↓:** حذف double-processing، UTC سخت، سلامت افزونه‌ها
*   **Speed ↑:** تحویل Foundation تا 15–20% سریع‌تر
*   **Quality ↑:** ثبات صف/وب‌هوک/فرم، کشف رگرسیون‌های افزونه‌ای

---

## ---8<--- END ---8<---

## ضمیمه: نسخهٔ قبلی (برای مرجع)

*(محتوای "سند مبنا برای ادامه توسعه افزونه" و "سند نهایی تجمیع‌شده: تحلیل وضعیت و نقشه‌ی راه SmartAlloc" از فایل اول حفظ می‌شود، اما از آنجا که ساختار اصلی و جزئیات فنی در بخش‌های بالا و در ادامهٔ این سند کامل‌تر ادغام شده‌اند، در اینجا تکرار نمی‌شود.)*

---

## سند نهایی تجمیع‌شده: تحلیل وضعیت و نقشه‌ی راه SmartAlloc (نسخهٔ نهایی ادغام‌شده)

### 1. معرفی پروژه و زمینه کلی

**پروژه:** سیستم تخصیص خودکار دانش‌آموز به پشتیبان (SmartAlloc) بر پایه وردپرس
**هدف اصلی:** افزونهٔ وردپرسی تولید-آماده برای تخصیص خودکار «پشتیبان» به «دانش‌آموز» با معماری Event-Driven، Command Pattern، DI Container، Cache سه‌لایه، Observability (Health, Metrics, Circuit Breaker) و ادغام کامل با Gravity Forms.
**پیش‌نیازها:** WP ≥ 6.4, PHP ≥ 8.1, MySQL 8+/MariaDB 10.5+
**فناوری‌های کلیدی:** وردپرس، PHP 8.1+، Gravity Forms Pro، PhpSpreadsheet، (اختیاری) Redis Object Cache / Object Cache Pro
**افزونه‌های ضروری:** Gravity Forms, Action Scheduler, (Prod فقط) WP Mail SMTP, (اختیاری) GP Populate Anything.

### 2. بررسی وضعیت فعلی پروژه بر اساس سند اجرایی

بررسی دقیق پروژه نشان می‌دهد که اگرچه بسیاری از ویژگی‌های اصلی پیاده‌سازی شده‌اند، اما چندین بخش حیاتی نیاز به تکمیل و بهینه‌سازی دارند:

*   **وضعیت کلی:** پروژه در فاز Foundation قرار دارد و حدود ۸۵٪ تکمیل شده است، اما برخی بخش‌های حیاتی از نظر فنی نیمه‌کاره باقی مانده‌اند.
*   **پوشش تست:** حدود ۷۰-۸۰٪، اما پوشش برای سناریوهای ترکیبی و مسیرهای بحرانی ناکافی است.
*   **ریسک‌های کلیدی:**
    *   عدم پیاده‌سازی کامل سیستم اعلانات (Throttling/DLQ).
    *   نیاز به استانداردسازی و تایپ‌دهی دقیق در مدارشکن.
    *   نیاز به پشتیبانی از شرایط ترکیبی در موتور قواعد.
    *   عدم بهینه‌سازی برای فایل‌های حجیم در خروجی‌گیری اکسل.
    *   عدم تضمین مسیر واحد برای پردازش فرم‌های Gravity Forms.

### 3. تحلیل دقیق لایه‌های پروژه و نیازهای تکمیلی

#### 3.1 لایه کاربردی - NotificationService

**بررسی با سند اجرایی:**
سند v1.2 الزام می‌کند تعداد تلاش‌های ارسال، سیاست‌های throttle و ارسال به DLQ به‌صورت پارامتریک و مانیتور‌شده باشد.

**وضعیت فعلی:**
*   استفاده از ثابت `SMARTALLOC_NOTIFY_MAX_TRIES` انجام شده است، اما هیچ مکانیزم نرخ‌گذاری، شمارش شکست سراسری یا اتصال مستقیم به DLQ/متریک‌ها پیاده نشده است.
*   مقدار پشتیبانی از بار در `handle()` اصلاح شده اما در `sendMail()` هنوز به‌صورت ثابت فراخوانی می‌شود.

**مشکلات شناسایی‌شده:**
*   عدم محدودسازی نرخ (throttle) در متد `handle`.
*   نبود ثبت متریک تفصیلی برای DLQ و شمارش تلاش‌های مجموع.
*   فراخوانی ثابت به `SMARTALLOC_NOTIFY_MAX_TRIES` بدون بررسی تعریف‌شدن.
*   نبود throttling برای جلوگیری از flood ارسال.
*   عدم انتشار رویداد مانیتورینگ هنگام push به DLQ.

**کدهای پیشنهادی برای نوشتن:**

```php
// داخل sendMail، قبل از مقایسهٔ تلاش‌ها
$maxTries = defined('SMARTALLOC_NOTIFY_MAX_TRIES') ? (int)SMARTALLOC_NOTIFY_MAX_TRIES : 5;

// افزودن RateLimiter با استفاده از ترانزی نت‌ها
private function throttle(string $key, int $limitPerMin): void {
    $count = (int) get_transient($key) ?: 0;
    if ($count >= $limitPerMin) {
        $this->metrics->inc('notify_throttle_hits_total');
        throw new \RuntimeException('Throttle limit reached');
    }
    set_transient($key, $count + 1, 60);
}

// استفاده در متد handle
public function handle(array $payload): void {
    $attempt = (int) ($payload['_attempt'] ?? 1);
    
    // اعمال Throttling
    $this->throttle('notify_' . gmdate('YmdHi'), SMARTALLOC_NOTIFY_RATE);

    if ($attempt >= $maxTries) {
        $this->eventBus->dispatch('notification.final_failure', [
            'correlation_id' => $this->correlationId,
            'payload' => $payload,
            'attempts' => $attempt
        ]);
        $this->dlqService->push($payload, 'notification');
        $this->metrics->increment('notification.dlq');
        return;
    }
    // ... ادامه عملیات
}
```

**تست‌های مورد نیاز:**

| نام تست                       | سناریو                                                       | پوشش        | الزام                    |
| ----------------------------- | ------------------------------------------------------------ | ----------- | ------------------------ |
| NotificationThrottleTest      | ارسال 11 اعلان در 60 ثانیه                                   | Unit        | جلوگیری از flood         |
| NotificationRetryLimitTest    | تلاش‌های بیش از SMARTALLOC_NOTIFY_MAX_TRIES                   | Unit        | احترام به مقدار پیکربندی |
| NotificationDlqMonitoringTest | ارسال به DLQ و انتشار رویداد                                 | Integration | مانیتورینگ کامل          |
| NotificationThrottleTest      | ارسال بیش از SMARTALLOC_NOTIFY_RATE در یک دقیقه و انتظار خطا | Unit        | p95 < 50ms               |

#### 3.2 لایه کاربردی - CircuitBreaker

**بررسی با سند اجرایی:**
مدارشکن باید خروجی‌های type-safe و کد مطابق استاندارد وردپرس باشد؛ استفاده از ثابت‌های تنظیمات.

**وضعیت فعلی:**
*   کد با `// phpcs:ignoreFile` نوشته شده و استانداردهای وردپرس را نادیده می‌گیرد.
*   خروجی‌های بدون نوع در `getStatus` و `getStatusReport` در CircuitBreaker.
*   عدم استفاده از ثابت‌های پیکربندی‌شده در تنظیمات.

**مشکلات شناسایی‌شده:**
*   بازگرداندن آرایه بدون تعریف دقیق نوع و حذف کامل PHPCS.
*   عدم استفاده از ثابت‌های پیکربندی در سازنده.
*   عدم پوشش حالت‌های ترکیبی (شبکه و دیتابیس) در تست‌ها.
*   عدم پشتیبانی از Threshold/Cooldown از تنظیمات.

**کدهای پیشنهادی برای نوشتن:**

```php
// DTO برای وضعیت مدارشکن
class CircuitBreakerStatus {
    public function __construct(
        public bool $isOpen,
        public ?int $failureCount,
        public ?int $openedAt,
        public ?int $nextAttempt,
        public string $serviceName
    ) {}
    
    public function toArray(): array {
        return [
            'is_open' => $this->isOpen,
            'failure_count' => $this->failureCount,
            'opened_at' => $this->openedAt,
            'next_attempt' => $this->nextAttempt,
            'service_name' => $this->serviceName
        ];
    }
}

// در کلاس CircuitBreaker
public function __construct(
    int $threshold = SMARTALLOC_CB_THRESHOLD,
    int $cooldown = SMARTALLOC_CB_COOLDOWN,
    ?callable $halfOpenCallback = null,
    ?CircuitStorage $storage = null
) {
    $this->threshold = $threshold;
    $this->cooldown = $cooldown;
    $this->halfOpenCallback = $halfOpenCallback;
    $this->storage = $storage ?: new TransientCircuitStorage();
}

public function getStatus(): CircuitBreakerStatus {
    $status = $this->getStatusArray();
    return new CircuitBreakerStatus(
        $status['is_open'],
        $status['failure_count'],
        $status['opened_at'],
        $status['next_attempt'], 
        $this->serviceName
    );
}

private function getStatusArray(): array {
    $failureCount = $this->counter->get($this->failureKey);
    $openedTs = $this->counter->get($this->openedKey);
    $nextAttempt = null;
    
    if ($openedTs && $openedTs > 0) {
        $nextAttempt = $openedTs + $this->config->cooldown;
    }
    
    return [
        'is_open' => $this->isOpen(),
        'failure_count' => $failureCount,
        'opened_at' => $openedTs,
        'next_attempt' => $nextAttempt ? $nextAttempt : null,
    ];
}
```

**تست‌های مورد نیاز:**

| نام تست                         | سناریو                                                    | پوشش        | الزام               |
| ------------------------------- | --------------------------------------------------------- | ----------- | ------------------- |
| CircuitBreakerStatusTypeTest    | بررسی نوع بازگشتی getStatus                               | Unit        | تایپ‌دهی دقیق        |
| CircuitBreakerMixedFailuresTest | توالی خطاهای شبکه و دیتابیس با آستانه مشترک               | Integration | Branch ≥ 85%        |
| CircuitBreakerComboFailureTest  | شکست ترکیبی شبکه+DB و بررسی ریست                          | Integration | پوشش حالت‌های ترکیبی |
| SettingsOverrideTest            | تغییر مقادیر threshold/cooldown از Settings و بررسی رفتار | Unit        | —                   |

#### 3.3 لایه کاربردی - Rule Engine

**بررسی با سند اجرایی:**
پشتیبانی از شرایط AND/OR، ثبت الگوهای منطقی در EvaluationResult و تست‌های جامع.

**وضعیت فعلی:**
*   موتور فقط یک شرط ساده fuzzy-score دارد و مدل نتیجه فاقد ساختار منطقی است.
*   تست‌های `RuleEngineControllerTest` با `markTestIncomplete` رها شده‌اند.
*   مدل `EvaluationResult` فاقد نمایش درخت منطقی (trace) است.

**مشکلات شناسایی‌شده:**
*   عدم پشتیبانی از شرایط ترکیبی (AND/OR) در قواعد.
*   `EvaluationResult` الگوی منطقی تصمیم را ذخیره نمی‌کند.
*   تست‌های REST برای موتور قواعد ناقص است.
*   عدم پشتیبانی از ترکیب شرایط.

**کدهای پیشنهادی برای نوشتن:**

```php
// EvaluationResult با پشتیبانی از درخت منطقی
class EvaluationResult {
    /** @var 'auto'|'manual'|'reject' */
    public string $decision;
    /** @var array<string,string> */
    public array $reasons = [];
    /** @var array<string,float> */
    public array $scores = [];
    /** @var array{op:string, rules:array<array<string,mixed>>} */
    public array $logicTree = [];

    public function __construct(string $decision = 'reject') {
        $this->decision = $decision;
    }

    public function addReason(string $reason): void {
        $this->reasons[] = $reason;
    }

    public function addScore(string $key, float $score): void {
        $this->scores[$key] = $score;
    }

    public function setLogicTree(array $tree): void {
        $this->logicTree = $tree;
    }
}

// Rule Engine با پشتیبانی از AND/OR
class RuleEngineService {
    private array $rules;
    
    public function __construct(array $rules) {
        $this->rules = $rules;
    }
    
    private function compare(mixed $actual, mixed $expected, string $operator): bool {
        switch ($operator) {
            case '>=': return $actual >= $expected;
            case '<=': return $actual <= $expected;
            case '>': return $actual > $expected;
            case '<': return $actual < $expected;
            case '==': return $actual == $expected;
            case '!=': return $actual != $expected;
            case '===': return $actual === $expected;
            case '!==': return $actual !== $expected;
            default:
                $this->logger->error('rule_engine.invalid_operator', ['operator' => $operator]);
                return false;
        }
    }

    private function evaluateNode(array $node, array $ctx, int $depth = 0): bool {
        if ($depth > 4) {
            throw new TooDeepRuleException("Rule depth exceeds maximum of 4");
        }
        
        if (isset($node['op'])) {
            $results = array_map(fn($r) => $this->evaluateNode($r, $ctx, $depth + 1), $node['rules']);
            return $node['op'] === 'AND' ? !in_array(false, $results, true) : in_array(true, $results, true);
        }
        // Simple condition
        return $this->compare($ctx[$node['field']] ?? null, $node['value'], $node['operator']);
    }

    public function evaluate(array $ctx): EvaluationResult {
        $result = new EvaluationResult('reject');
        
        // مثال برای درخت منطقی
        $exampleLogicTree = [
            'op' => 'AND',
            'rules' => [
                ['field' => 'school_fuzzy', 'operator' => '>=', 'value' => 0.90],
                ['field' => 'city', 'operator' => '===', 'value' => ($ctx['preferred_city'] ?? '')]
            ]
        ];
        
        try {
            $logicPassed = $this->evaluateNode($exampleLogicTree, $ctx);
            $result->setLogicTree($exampleLogicTree);

            if ($logicPassed) {
                $result->decision = 'auto';
                $result->addReason('auto_allocation_rules_met');
            } else {
                $result->decision = 'reject';
                $result->addReason('rule_engine_failed');
            }
        } catch (TooDeepRuleException $e) {
            $result->decision = 'reject';
            $result->addReason('rule_too_deep');
        } catch (InvalidRuleOperatorException $e) {
            $result->decision = 'reject';
            $result->addReason('invalid_operator');
        }

        // اضافه کردن امتیازها
        $result->addScore('school_fuzzy', (float)($ctx['school_fuzzy'] ?? 0));

        return $result;
    }
}
```

**تست‌های مورد نیاز:**

| نام تست                        | سناریو                               | پوشش        | الزام                   |
| ------------------------------ | ------------------------------------ | ----------- | ----------------------- |
| RuleEngineAndOrTest            | ارزیابی قواعد مرکب AND/OR            | Unit        | تصمیم صحیح بر اساس درخت |
| RuleEngineCompositeAndTest     | دو شرط AND                           | Unit        | شرایط ترکیبی            |
| RuleEngineCompositeOrTest      | OR با یکی true                       | Unit        | شرایط ترکیبی            |
| RuleEngineExpressionResultTest | ذخیرهٔ درخت منطقی در EvaluationResult | Unit        | الگوهای منطقی           |
| RuleEngineControllerAuthTest   | درخواست صحیح با تصمیم «auto»         | Integration | JSON با decision        |

#### 3.4 نگرانی‌های بین‌لایه‌ای - Logging & Observability

**بررسی با سند اجرایی:**
لاگ ساخت‌یافته با Correlation ID، Tracer در تمام لایه‌ها و اندپوینت‌های Health/Metrics کامل.

**وضعیت فعلی:**
*   Logging فاقد Correlation ID است.
*   Tracer فقط در حالت تست و محدود استفاده می‌شود.
*   اندپوینت Health تنها وضعیت ساده دیتابیس و کش را برمی‌گرداند.

**مشکلات شناسایی‌شده:**
*   عدم تزریق Correlation ID در همه لاگ‌ها.
*   عدم استفاده از Tracer در تمام لایه‌ها.
*   اندپوینت‌های Health/Metrics وضعیت مدارشکن و DLQ را گزارش نمی‌کنند.

**کدهای پیشنهادی برای نوشتن:**

```php
// Logger با پشتیبانی از Correlation ID
class StructuredLogger implements LoggerInterface {
    private string $correlationId;
    
    public function __construct(?string $correlationId = null) {
        $this->correlationId = $correlationId ?? uniqid('cid-', true);
    }
    
    public function log(string $level, string $message, array $context = []): void {
        $context = array_merge([
            'correlation_id' => $this->correlationId,
            'timestamp' => gmdate('Y-m-d\TH:i:s\Z')
        ], $context);
        
        // اطمینان از عدم وجود اطلاعات حساس
        $context = Redactor::sanitize($context);
        
        // ارسال به وردپرس لاگ
        error_log(sprintf(
            "[%s] %s: %s %s",
            $level,
            $this->correlationId,
            $message,
            json_encode($context)
        ));
    }
}

// Tracer برای پروفایلینگ
class Tracer {
    private string $correlationId;
    private array $spans = [];
    
    public function __construct(string $correlationId) {
        $this->correlationId = $correlationId;
    }
    
    public function startSpan(string $name): Span {
        $span = new Span($name, microtime(true));
        $this->spans[$name] = $span;
        return $span;
    }
    
    public function finish(): void {
        foreach ($this->spans as $span) {
            $this->logger->debug('Span completed', [
                'span' => $span->name,
                'duration_ms' => $span->getDuration(),
                'correlation_id' => $this->correlationId
            ]);
        }
    }
}

// گسترش اندپوینت Health
public function health_check(): WP_REST_Response {
    $status = [
        'db' => $this->check_db(),
        'cache' => $this->check_cache(),
        'circuit_breaker' => $this->circuitBreaker->getStatus(),
        'dlq_count' => $this->dlq->getCount()
    ];
    return new WP_REST_Response($status);
}
```

**تست‌های مورد نیاز:**

| نام تست                          | سناریو                                               | پوشش        | الزام             |
| -------------------------------- | ---------------------------------------------------- | ----------- | ----------------- |
| CorrelationIdPropagationTest     | ارسال Correlation ID در چند سرویس و بررسی ثبت در لاگ | Integration | —                 |
| TracerSpanCompletionTest         | اطمینان از finish در مسیرهای خطا                     | Unit        | استفاده از Tracer |
| HealthIncludesCircuitBreakerTest | اندپوینت Health وضعیت مدارشکن و DLQ را برمی‌گرداند    | Integration | —                 |
| HealthCircuitBreakerTest         | وقتی مدار باز است، پاسخ health ok=false              | Integration | شبیه‌سازی خطا      |
| MetricsCircuitBreakerTest        | گزارش status مدارشکن                                 | Integration | اندپوینت متریک    |

#### 3.5 لایه کاربردی - ExportService

**بررسی با سند اجرایی:**
خروجی اکسل باید با استریم chunk‌محور، نرمال‌سازی و Bulk Insert کامل باشد.

**وضعیت فعلی:**
*   تولید فایل به‌صورت کامل در حافظه و عدم Bulk Insert خطاها.
*   قوانین نرمال‌سازی/اعتبارسنجی حداقلی هستند.
*   عملیات روی دادهٔ داخل حافظه انجام می‌شود و استریم استفاده نشده است.

**مشکلات شناسایی‌شده:**
*   مصرف بالای حافظه برای فایل‌های بزرگ.
*   عدم استریم و عدم استفاده از bulkInsertErrors با SQL واحد.
*   قوانین نرمال‌سازی/اعتبارسنجی ناقص.

**کدهای پیشنهادی برای نوشتن:**

```php
private function writeXlsx(iterable $rows, string $file): void {
    $spreadsheet = new Spreadsheet();
    $sheet = $spreadsheet->getActiveSheet();
    $rowIdx = 1;
    
    foreach ($rows as $row) {
        foreach ($this->config->columns as $colIdx => $field) {
            $value = (string)($row[$field] ?? '');
            // حفظ صفرهای پیشرو
            $sheet->setCellValueExplicitByColumnAndRow(
                $colIdx + 1,
                $rowIdx,
                $value,
                DataType::TYPE_STRING
            );
        }
        $rowIdx++;
        
        // مدیریت حافظه برای فایل‌های بزرگ
        if ($rowIdx % 500 === 0) {
            $sheet->garbageCollect();
        }
    }
    
    // استفاده از Writer به جای save برای استریم
    $writer = new Xlsx($spreadsheet);
    $writer->save($file);
    $spreadsheet->disconnectWorksheets();
    unset($spreadsheet);
}

// Bulk Insert برای خطاها
public function bulkInsertErrors(int $logId, array $errors): void {
    if (!$errors) {
        return;
    }
    global $wpdb;
    $table = $wpdb->prefix . 'smartalloc_export_errors';
    $values = [];
    $params = [];
    foreach ($errors as $e) {
        $values[] = '(%d,%d,%d,%s,%s)';
        $params[] = $logId;
        $params[] = $e['form_id'] ?? 0;
        $params[] = $e['row'];
        $params[] = $e['column'];
        $params[] = $e['message'];
    }
    $sql = "INSERT INTO {$table} (export_id,form_id,row_index,column_name,message) VALUES " . implode(',', $values);
    // Use DbSafe::mustPrepare for all dynamic SQL
    $wpdb->query(DbSafe::mustPrepare($sql, $params));
}
```

**تست‌های مورد نیاز:**

| نام تست                    | سناریو                                | پوشش        | الزام                  |
| -------------------------- | ------------------------------------- | ----------- | ---------------------- |
| ExportStreamMemoryTest     | خروجی ۱۰k رکورد با مصرف حافظه < 128MB | Performance | p95 < 2s               |
| ExportLargeDatasetPerfTest | 1000 رکورد، p95<2s                    | Performance | الزامات عملکرد         |
| ExportNormalizationTest    | صفرهای پیشرو حفظ شوند                 | Unit        | قوانین نرمال‌سازی       |
| ExportValidationRulesTest  | خطای Postal/City mismatch             | Unit        | درج خطا در sheet Error |

#### 3.6 لایه کاربردی - CrosswalkService

**بررسی با سند اجرایی:**
باید L1/L2 Cache و مکانیزم invalidation کامل داشته باشد.

**وضعیت فعلی:**
*   فقط L1 cache بدون مکانیزم invalidation استفاده می‌شود.
*   کش L1 استفاده می‌شود ولی invalidation تنها با ثبت یک لاگ انجام می‌شود.

**مشکلات شناسایی‌شده:**
*   نبود invalidation هنگام تغییر داده‌ها.
*   عدم استفاده از L2 cache یا TTL پویای قرارداد.
*   نبود نسخه‌بندی کش و invalidation واقعی.

**کدهای پیشنهادی برای نوشتن:**

```php
class CrosswalkService {
    private const CACHE_GROUP = 'smartalloc_crosswalk';
    private const CACHE_VERSION_KEY = 'crosswalk_version';
    
    private $cache;
    private $db;
    
    public function __construct(CacheInterface $cache, DbInterface $db) {
        $this->cache = $cache;
        $this->db = $db;
    }
    
    public function getVersion(): int {
        $version = $this->cache->get(self::CACHE_VERSION_KEY, self::CACHE_GROUP);
        if ($version === false) {
            $version = (int)$this->db->get_var(
                "SELECT UNIX_TIMESTAMP(MAX(updated_at)) FROM {$this->db->prefix}smart_alloc_crosswalk"
            );
            $this->cache->set(self::CACHE_VERSION_KEY, $version, 0, self::CACHE_GROUP);
        }
        return $version;
    }
    
    private function versionedKey(string $baseKey): string {
        return $baseKey . ':v' . $this->getVersion();
    }
    
    public function getCrosswalkData(): array {
        $cacheKey = $this->versionedKey('crosswalk_data');
        $data = $this->cache->get($cacheKey, self::CACHE_GROUP);
        
        if ($data === false) {
            $data = $this->db->get_results(
                "SELECT * FROM {$this->db->prefix}smart_alloc_crosswalk",
                ARRAY_A
            );
            $this->cache->set($cacheKey, $data, HOUR_IN_SECONDS, self::CACHE_GROUP);
        }
        
        return $data;
    }
    
    public function invalidateCache(): void {
        $this->cache->set(
            self::CACHE_VERSION_KEY, 
            time(), 
            0, 
            self::CACHE_GROUP
        );
    }
}
```

**تست‌های مورد نیاز:**

| نام تست                        | سناریو                                                       | پوشش        | الزام                |
| ------------------------------ | ------------------------------------------------------------ | ----------- | -------------------- |
| CrosswalkCacheVersioningTest   | تغییر داده‌ها و بررسی نسخه‌بندی کش                             | Unit        | invalidation صحیح    |
| CrosswalkL2CacheTest           | استفاده از Redis به عنوان L2 cache                           | Integration | پشتیبانی از L2 cache |
| CrosswalkVersionBumpTest       | فراخوانی invalidate() باید نسخه کش را افزایش دهد             | Unit        | —                    |
| CrosswalkCacheInvalidationTest | پس از invalidate()، فراخوانی schoolCodeByName باید داده‌ها را از DB بازیابی کند | Integration | —                    |

### 4. اولویت‌بندی کلی اقدامات

| سطح اولویت | اقدام                                              | تخمین زمان | تأثیر | الزام سند اجرایی         |
| ---------- | -------------------------------------------------- | ---------- | ----- | ------------------------ |
| فوری       | تکمیل NotificationService (throttle + DLQ metrics) | 2 روز      | بالا  | الزامات امنیتی و عملکردی |
| فوری       | پیاده‌سازی typed CircuitBreaker                     | 1 روز      | بالا  | الزامات Observability    |
| فوری       | رفع تست‌های ناقص برای جلوگیری از رگرسیون            | 1.5 روز    | بالا  | الزامات کیفیت            |
| مهم        | پشتیبانی AND/OR در Rule Engine و ساختار منطقی      | 2 روز      | بالا  | الزامات کسب‌وکار          |
| مهم        | استریم و Bulk Insert در ExportService              | 2 روز      | بالا  | الزامات عملکردی          |
| مهم        | اضافه‌کردن Correlation ID و Tracer در Logging       | 1.5 روز    | متوسط | الزامات Observability    |
| متوسط      | نسخه‌گذاری و invalidation در CrosswalkService       | 1 روز      | متوسط | الزامات کش               |
| متوسط      | پوشش تست VIP/Performance                           | 1.5 روز    | متوسط | الزامات سازگاری          |

### 5. هشدارهای امنیتی حیاتی

#### 5.1 ریسک‌های امنیتی اصلی

*   **کد SQL دستی:** استفاده گسترده از global `$wpdb` در سرویس‌ها (مثل ExportService و CrosswalkService) ریسک تزریق SQL دارد؛ اطمینان از `DbSafe::mustPrepare` در همهٔ کوئری‌ها ضروری است.
*   **عدم اعتبارسنجی کامل ورودی‌ها:** اندپوینت‌های REST پارامترها را فقط به‌صورت سطحی بررسی می‌کنند؛ باید از `sanitize_text_field` و `rest_validate_value_from_schema` برای همهٔ فیلدها استفاده شود.
*   **Rate limiting:** بدون throttling در NotificationService، امکان حملهٔ DoS به سیستم اعلانات وجود دارد.
*   **داده‌های حساس در لاگ:** در Logger باید اطمینان حاصل شود که Correlation ID و context فاقد اطلاعات حساس (PII) هستند؛ `Redactor` باید قبل از ثبت، داده‌ها را ماسک کند.
*   **Observability:** نبود گزارش مدارشکن در health باعث پنهان‌ماندن خطاهای پیوسته می‌شود.
*   **Cache invalidation:** عدم نسخه‌بندی Crosswalk می‌تواند داده‌های قدیمی را در اختیار کاربران قرار دهد که ریسک logic bug محسوب می‌شود.

#### 5.2 راهکارهای امنیتی پیشنهادی

```php
// بررسی و پارامترسازی کوئری‌ها
public function safeQuery(string $sql, ...$params): mixed {
    $prepared = $this->db->prepare($sql, $params);
    return $this->db->query($prepared);
}

// اعتبارسنجی ورودی‌های REST
protected function validateRequest(array $request): array {
    $schema = [
        'type' => 'object',
        'properties' => [
            'student_id' => [
                'type' => 'integer',
                'minimum' => 1
            ],
            'mentor_id' => [
                'type' => 'integer',
                'minimum' => 1
            ]
        ],
        'required' => ['student_id', 'mentor_id']
    ];
    
    $valid = rest_validate_value_from_schema($request, $schema, 'request');
    if (is_wp_error($valid)) {
        throw new \Exception($valid->get_error_message());
    }
    
    return [
        'student_id' => (int)$request['student_id'],
        'mentor_id' => (int)$request['mentor_id']
    ];
}

// Redactor برای پاک‌سازی داده‌های حساس
class Redactor {
    private const SENSITIVE_FIELDS = [
        'national_id', 'phone', 'email', 'postal_code'
    ];
    
    public static function sanitize(array $data): array {
        foreach (self::SENSITIVE_FIELDS as $field) {
            if (isset($data[$field])) {
                $data[$field] = self::maskValue($data[$field]);
            }
        }
        return $data;
    }
    
    private static function maskValue(string $value): string {
        $length = strlen($value);
        if ($length <= 4) {
            return '****';
        }
        return substr($value, 0, 2) . '****' . substr($value, -2);
    }
}
```

### 6. پیشنهادات نهایی و توصیه‌ها

#### 6.1 الزامات کلیدی برای اجرای موفق

*   **رعایت استانداردها:** تمام کدهای پیشنهادی باید با استانداردهای WordPress و PSR-12 سازگار باشند و از `gmdate()` برای زمان UTC استفاده کنند.
*   **لاگ‌گیری ساختارمند:** لاگ‌ها باید شامل correlation و متریک‌ها با نام‌گذاری سازگار (snake_case) باشند.
*   **تست‌های جامع:** برای هر تغییر، تست‌های Unit/Integration/Performance مطابق جداول بالا تهیه و اجرا شوند.
*   **نرمال‌سازی کامل:** قوانین نرمال‌سازی و اعتبارسنجی کامل شوند (به ویژه برای فیلدهای با صفر پیشرو).
*   **بهینه‌سازی حافظه:** ExportService برای فایل‌های بزرگ با استفاده از استریم و chunking بهینه‌سازی شود.

#### 6.2 گام‌های بعدی پیشنهادی

*   **تکمیل سیستم اعلانات:**
    *   پیاده‌سازی مکانیزم throttle بر اساس RateLimiter.
    *   ادغام کامل با DLQ و متریک‌ها.
    *   پیاده‌سازی سیاست‌های ارسال پارامتریک.
*   **بهبود موتور قواعد:**
    *   پشتیبانی از شرایط ترکیبی (AND/OR).
    *   افزودن ساختار درخت منطقی به EvaluationResult.
    *   تکمیل تست‌های RuleEngineController.
*   **بهینه‌سازی خروجی‌گیری:**
    *   پیاده‌سازی استریم برای فایل‌های حجیم.
    *   افزودن قوانین نرمال‌سازی و اعتبارسنجی کامل.
    *   پیاده‌سازی Bulk Insert برای خطاها.
*   **تکمیل Observability:**
    *   افزودن Correlation ID به تمام لاگ‌ها.
    *   پیاده‌سازی Tracer در تمام لایه‌ها.
    *   گسترش اندپوینت‌های Health/Metrics برای گزارش مدارشکن و DLQ.

این سند نهایی بر اساس تحلیل دقیق تمام گزارش‌های ارسالی و سند اجرایی پروژه تهیه شده و نقشه راهی جامع برای تکمیل پروژه SmartAlloc ارائه می‌دهد. پیروی از این نقشه راه تضمین می‌کند که پروژه به صورت کامل، ایمن و مطابق با الزامات سند اجرایی (v2.0) تکمیل شود.

**Reference:** `PATCH_GUARD_STANDARDS_WordPress_2025-09-07.md` — canonical rules, exceptions and tooling.